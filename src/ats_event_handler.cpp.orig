/*
 * This class implmentats callbacks function that are called by ATS
 * AUTHORS:
 *   Vmon: May 2013, moving Bill's code to C++
 */
#include <stdio.h>
#include <ts/ts.h>
#include <regex.h>
#include <string.h>

#include <string>
#include <vector>
#include <list>

#include <zmq.hpp>
using namespace std;

#include <re2/re2.h>
//to retrieve the client ip
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

//to run fail2ban-client
#include <stdlib.h>

#include <mysql.h>
#include <my_global.h>

#include "db_tools.h"
#include "regex_manager.h"
#include "challenge_manager.h"
#include "banjax.h"
#include "banjax_continuation.h"
#include "swabber_interface.h"
#include "ats_event_handler.h"
/*the glabal_cont the global continuation that is generated by
  by the banjax object.*/
//TSCont Banjax::global_contp;
//extern TSMutex Banjax::regex_mutex;

//Swabber connection detail
const string SwabberInterface::SWABBER_SERVER = "*";
const string SwabberInterface::SWABBER_PORT =  "22620";
const string SwabberInterface::SWABBER_BAN = "swabber_bans";

const unsigned int SwabberInterface::SWABBER_MAX_MSG_SIZE = 1024;

const unsigned int ATSEventHandler::RETRY_TIME = 10;
SwabberInterface ATSEventHandler::swabber_interface;

/* Constructor, inform the handler object about the global cont.
 */
ATSEventHandler::ATSEventHandler()
{

}

//Auxilary functions
void ATSEventHandler::ts_handle_cleanup(TSMBuffer bufp,
                                   TSMLoc hdr_loc,
                                   TSMLoc url_loc = NULL,
                                   TSMLoc ua_loc = NULL,
                                   TSMLoc cookie_loc = NULL)
{
  
  if (url_loc) TSHandleMLocRelease(bufp, hdr_loc, url_loc);
  if (ua_loc) TSHandleMLocRelease(bufp, hdr_loc, ua_loc);
  if (cookie_loc) TSHandleMLocRelease(bufp, hdr_loc, url_loc);
  TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc);

}

void ATSEventHandler::take_normal_couse_of_events(TSHttpTxn txnp)
{
      TSHttpTxnReenable(txnp, TS_EVENT_HTTP_CONTINUE);
}

int
ATSEventHandler::banjax_global_eventhandler(TSCont contp, TSEvent event, void *edata)
{
  TSHttpTxn txnp = (TSHttpTxn) edata;
  BanjaxContinuation *cd;

  //raise(SIGINT);
  switch (event) {
  case TS_EVENT_HTTP_READ_REQUEST_HDR:
    TSDebug("banjax", "request" );
    if(contp != Banjax::global_contp) {
      cd = (BanjaxContinuation *) TSContDataGet(contp);
      cd->cf = BanjaxContinuation::HANDLE_REQUEST;
      handle_request(txnp, contp);
      return 0;
    } else {
      break;
    }
  case TS_EVENT_HTTP_TXN_START:
    TSDebug("banjax", "txn start" );
	txnp = (TSHttpTxn) edata;
    handle_txn_start(contp, txnp);
    return 0;
  case TS_EVENT_HTTP_TXN_CLOSE:
    TSDebug("banjax", "txn close" );
    txnp = (TSHttpTxn) edata;
    if (contp != Banjax::global_contp) {
      destroy_continuation(txnp, contp);
    }
    break;
  case TS_EVENT_HTTP_SEND_RESPONSE_HDR:
    TSDebug("banjax", "response" );
    if (contp != Banjax::global_contp) {
      cd = (BanjaxContinuation *) TSContDataGet(contp);
      cd->cf = BanjaxContinuation::HANDLE_RESPONSE;

      TSDebug("banjax", "response_type = %d", cd->response_type);

      handle_response(cd->txnp, contp, cd->response_type);
      return 0;
    } else {
      break;
    }
  case TS_EVENT_TIMEOUT:
    TSDebug("banjax", "timeout" );
    /* when mutex lock is not acquired and continuation is rescheduled,
       the plugin is called back with TS_EVENT_TIMEOUT with a NULL
       edata. We need to decide, in which function did the MutexLock
       failed and call that function again */
    if (contp != Banjax::global_contp) {
      cd = (BanjaxContinuation *) TSContDataGet(contp);
      switch (cd->cf) {
      case BanjaxContinuation::HANDLE_REQUEST:
        handle_request(cd->txnp, contp);
        return 0;
      default:
        TSDebug("banjax", "This event was unexpected: %d\n", event);
        break;
      }
    } else {
      //regardless, it even doesn't make sense to read the list here
      //read_regex_list(contp);
      return 0;
    }

  default:
    TSDebug("banjax", "default" );
    break;
  }
  return 0;
}

void
ATSEventHandler::handle_request(TSHttpTxn txnp, TSCont contp)
{
<<<<<<< HEAD
>>>>>>> variant B
  TSMBuffer bufp = NULL;
  TSMLoc hdr_loc = NULL;
  TSMLoc host_loc = NULL;
  TSMLoc ua_loc = NULL;
  TSMLoc url_loc = NULL;
  TSMLoc cookie_loc = NULL;
  //allocate memory in stack to improve efficiency of not allocating
  //and delocating millions of time it is also interesting for 
  //the matter of DDoS to sotp GET Requests of larger than some size
  char url[MAX_URL_LENGTH];
  char ua[MAX_UA_LENGTH];
  const char separator = " ";
  char request[MAX_REQUEST_LENGTH];
  int64_t request_len[MAX_REQUEST_LENGTH];
  unsigned int host_length, url_length, ua_length;
=======
  TSMBuffer bufp;
  TSMLoc hdr_loc;
  TSMLoc ua_loc;
//  TSMLoc client_loc;
  TSMLoc url_loc;
  const char *url;
  const char *ua;
  const char separator = ' ';
  int url_length,ua_length;
  char *request;
  regex_t regex;
  int64_t request_len;
>>>>>>> Redirct-traffic-to-solver
  int reti;
  char msgbuf[100];
  struct sockaddr_in* client_address;
  // for cookie and js challenge
  const char *cookie_value;
<<<<<<< HEAD
  const char *client_ip; 
  long time_validity;       // unix time until which the cookie will be valid
=======
  char *client_ip; 
  TSMLoc cookie_loc;
>>>>>>> Redirct-traffic-to-solver
  int cookie_length;

  BanjaxContinuation* cd = (BanjaxContinuation *) TSContDataGet(contp); //we need to retrieve
  //Banjax main object cause all of our object are accesible through it
  Banjax* banjax = cd->cur_banjax_inst;

  //our strategy here is to ban as soon as possible 

  //retrieving header
  if (TSHttpTxnClientReqGet(txnp, &bufp, &hdr_loc) != TS_SUCCESS) {
    TSError("couldn't retrieve client response header\n");
    return take_normal_couse_of_events(txnp);
  }

  //retrieving url
  if (TSHttpHdrUrlGet(bufp, hdr_loc, &url_loc) != TS_SUCCESS) {
    TSError("couldn't retrieve request url\n");
    ts_handle_cleanup(bufp, hdr_loc);
    return take_normal_couse_of_events(txnp);
  }

  url = TSUrlStringGet(bufp, url_loc, &url_length);
  if (!url){
    TSError("couldn't retrieve request url string\n");
<<<<<<< HEAD
    ts_handle_cleanup(bufp, hdr_loc, url_loc);
    return take_normal_couse_of_events(txnp);
  }

=======
    TSHandleMLocRelease(bufp, hdr_loc, url_loc);
    TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc);
    goto done;
    }
  
>>>>>>> Redirct-traffic-to-solver
  TSDebug("banjax", "URL: %s", url );
  
  host_loc = TSMimeHdrFieldFind(bufp, hdr_loc, TS_MIME_FIELD_HOST, TS_MIME_LEN_HOST);
  if (host_loc == TS_NULL_MLOC)
  {
    TSError("couldn't retrieve request host\n");
    ts_handle_cleanup(bufp, hdr_loc, url_loc);
    return take_normal_couse_of_events(txnp);
  }

  host = TSMimeHdrFieldValueStringGet(bufp,hdr_loc,host_loc,0,&host_length);	
  if (!host){
    TSError("couldn't retrieve request host string\n");
    ts_handle_cleanup(bufp, hdr_loc, url_loc);
    return take_normal_couse_of_events(txnp);
  }

  ua_loc = TSMimeHdrFieldFind(bufp, hdr_loc, TS_MIME_FIELD_USER_AGENT, TS_MIME_LEN_USER_AGENT);
  if (ua_loc == TS_NULL_MLOC)
  {
    TSError("couldn't retrieve request user-agent\n");
    ts_handle_cleanup(bufp, hdr_loc, url_loc, ua_loc);
    return take_normal_couse_of_events(txnp);
  }

  ua = TSMimeHdrFieldValueStringGet(bufp,hdr_loc,ua_loc,0,&ua_length);	
  if (!ua){                                                                                 TSError("couldn't retrieve request url string\n");
    ts_handle_cleanup(bufp, hdr_loc, url_loc, ua_loc);
    return take_normal_couse_of_events(txnp);
  }
<<<<<<< HEAD

=======
  
>>>>>>> Redirct-traffic-to-solver
  TSDebug("banjax", "ua: %s",ua );
  request_len = url_length + host_length + ua_length ;

  //simulating ATS log record
  request = (char*)TSmalloc(request_len+2);
  memcpy(request,url, url_length*sizeof(char));
<<<<<<< HEAD
  memcpy(request+url_length, separator, 1*sizeof(char));
  memcpy(request+url_length+1, host, host_length*sizeof(char));  
  memcpy(request+url_length+1+host_length, separator, 1*sizeof(char));
  memcpy(request+url_length+1+host_length+1, ua, ua_length*sizeof(char));  
  request[url_length+host_length+ua_length+2] = '\0';
=======
  request[url_length] = separator;
  memcpy(request+url_length+1, ua, ua_length*sizeof(char));  
  request[url_length+ua_length+1] = '\0';
>>>>>>> Redirct-traffic-to-solver
 
  TSDebug("banjax", "request: %s", request);

  reti = banjax->regex_manager->parse_request(request);

<<<<<<< HEAD
  TSDebug("banjax", "executed regex");

  if( reti == RegexManager::REGEX_MATCHED ){
=======
  if( reti == RegexManager::REGEX_MATCHED){
>>>>>>> Redirct-traffic-to-solver
    TSDebug("banjax", "banning request: %s\n", request);

    //Retrieving the ip address, this is for test
    //so we assume IPv4 for now
    client_address = (struct sockaddr_in*) TSHttpTxnClientAddrGet(txnp);
    
    if (!client_address) {
        TSError("error in retrieving client ip\n");
        ts_handle_cleanup(bufp, hdr_loc, url_loc, ua_loc);
        return take_normal_couse_of_events(txnp);
    }

    char* client_ip_str = inet_ntoa(client_address->sin_addr);

    TSDebug("banjax", "banning client ip: %s", client_ip_str);

    //here instead we are calling nosmos's banning client
    //swabber_interface.ban(client_ip_str);

    BanjaxContinuation *cd = (BanjaxContinuation *) TSContDataGet(contp);
    cd->response_type = 1; //TODO: response type should be set by the filter

    TSHttpTxnHookAdd(txnp, TS_HTTP_SEND_RESPONSE_HDR_HOOK, contp);
    TSHandleMLocRelease(bufp, hdr_loc, url_loc);
    TSHandleMLocRelease(bufp, hdr_loc, host_loc);
    TSHandleMLocRelease(bufp, hdr_loc, ua_loc);
    TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc);
    TSHttpTxnReenable(txnp, TS_EVENT_HTTP_ERROR);
    return;
<<<<<<< HEAD

  } else if (reti == RegexManager::REGEX_MISSED){
    TSDebug("banjax", "No match found");

=======
  } else if (reti == RegexManager::REGEX_MISSED || 1==1){
    //Add regex and request string
    TSDebug("banjax", "regex: no match found");
>>>>>>> Redirct-traffic-to-solver
  } else {
    TSError("Regex failed with error: %s\n", msgbuf);
  }

<<<<<<< HEAD
  TSDebug("banjax", "retrieving client ip");

  //Retrieving the ip address,
  //so we assume IPv4 for now
  client_address = (struct sockaddr_in*) TSHttpTxnClientAddrGet(txnp);
    
  if (!client_address) {
    TSError("error in retrieving client ip\n");
    ts_handle_cleanup(bufp, hdr_loc, url_loc, ua_loc);
    return take_normal_couse_of_events(txnp);
=======
  //Retrieving the ip address
  client_address = (struct sockaddr_in*) TSHttpTxnClientAddrGet(txnp);
   
  if (!client_address) {
      TSError("error in retrieving client ip\n");
      TSHandleMLocRelease(bufp, hdr_loc, url_loc);
      TSHandleMLocRelease(bufp, hdr_loc, ua_loc);
      TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc);                       
      goto done;
>>>>>>> Redirct-traffic-to-solver
  }

  client_ip = inet_ntoa(client_address->sin_addr);
  TSDebug("banjax", "client_ip: %s",client_ip );

  /*
   * checking the cookie and serving the js challenge if does not pass
   */
  TSDebug("banjax", "Checking for challenge");
  cookie_loc = TSMimeHdrFieldFind(bufp, hdr_loc, TS_MIME_FIELD_COOKIE, TS_MIME_LEN_COOKIE);

  if (cookie_loc == TS_NULL_MLOC)
  {
    TSDebug("banjax", "couldn't retrieve request cookie, sending challenge\n");
 
<<<<<<< HEAD
    ts_handle_cleanup(bufp, hdr_loc, url_loc, ua_loc, cookie_loc);

    TSHttpTxnErrorBodySet(txnp, buf, strlen(buf), NULL);
    TSHttpTxnReenable(txnp, TS_EVENT_HTTP_CONTINUE);

    //TSHttpTxnErrorBodySet(txnp, buf, strlen(buf), NULL);	
    //TSHttpTxnReenable(txnp, TS_EVENT_HTTP_CONTINUE);
    //TSHttpTxnHookAdd(txnp, TS_HTTP_SEND_RESPONSE_HDR_HOOK, contp);

    //destroy_continuation(txnp, contp);
=======
    BanjaxContinuation *cd = (BanjaxContinuation *) TSContDataGet(contp);
    cd->response_type = 2;

    TSHttpTxnHookAdd(txnp, TS_HTTP_SEND_RESPONSE_HDR_HOOK, contp);
    TSHandleMLocRelease(bufp, hdr_loc, url_loc);
    TSHandleMLocRelease(bufp, hdr_loc, ua_loc);
    TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc);
    TSHttpTxnReenable(txnp, TS_EVENT_HTTP_ERROR);
    TSMutexUnlock(Banjax::regex_mutex);
>>>>>>> Redirct-traffic-to-solver
    return;
  }
  else
  {
    cookie_value = TSMimeHdrFieldValueStringGet(bufp,hdr_loc,cookie_loc,0,&cookie_length);	
    if (!cookie_value)
    {                                                                                              
      TSError("couldn't retrieve request url string\n");
      TSHandleMLocRelease(bufp, hdr_loc, url_loc);
      TSHandleMLocRelease(bufp, hdr_loc, cookie_loc);
      TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc);                                                     
      return take_normal_couse_of_events(txnp);
    }

    TSDebug("banjax", "cookie_value: %s", cookie_value );
    if(!ChallengeManager::check_cookie(cookie_value, client_ip))
      {
        TSDebug("banjax", "cookie is not valid, sending challenge");
 
        BanjaxContinuation *cd = (BanjaxContinuation *) TSContDataGet(contp);
        cd->response_type = 2;

        TSHttpTxnHookAdd(txnp, TS_HTTP_SEND_RESPONSE_HDR_HOOK, contp);
        TSHandleMLocRelease(bufp, hdr_loc, url_loc);
        TSHandleMLocRelease(bufp, hdr_loc, ua_loc);
        TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc);
        TSHttpTxnReenable(txnp, TS_EVENT_HTTP_ERROR);
        TSMutexUnlock(Banjax::regex_mutex);
        return;
      }  

    TSDebug("banjax", "cookie is valid, continuing");

    TSMutexUnlock(Banjax::regex_mutex);
    TSHandleMLocRelease(bufp, hdr_loc, url_loc);
    TSHandleMLocRelease(bufp, hdr_loc, ua_loc);
    TSHandleMLocRelease(bufp, hdr_loc, cookie_loc);
    TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc);
    //regfree(&regex);  
  }

  return take_normal_couse_of_events(txnp);
}

void
ATSEventHandler::handle_response(TSHttpTxn txnp, TSCont contp, int response_type)
{
  TSMBuffer bufp;
  TSMLoc hdr_loc;
  TSMLoc url_loc, host_loc;
  const char *host_str;
  char *url_str;
  char *url;
  char *host;
  char *buf;
  string buf_str;
  int url_length, host_length;
  long time_validity;
  struct sockaddr_in* client_address;
  const char *client_ip; 
  int x = 7;

  if (TSHttpTxnClientRespGet(txnp, &bufp, &hdr_loc) != TS_SUCCESS) {
    TSError("couldn't retrieve client response header\n");
    goto done;
  }

  
  if (TSHttpTxnClientReqGet(txnp, &bufp, &hdr_loc) != TS_SUCCESS) {
    TSError("couldn't retrieve client request header\n");
    TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc);
    goto done;
  }

  if (TSHttpHdrUrlGet(bufp, hdr_loc, &url_loc) != TS_SUCCESS) {
    TSError("couldn't retrieve request url\n");
    TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc);
    goto done;
  }
  
  host_loc = TSMimeHdrFieldFind(bufp, hdr_loc, TS_MIME_FIELD_HOST, TS_MIME_LEN_HOST);

  if (host_loc == TS_NULL_MLOC)
  {
    TSError("couldn't retrieve request user-agent\n");
    TSHandleMLocRelease(bufp, hdr_loc, url_loc);
    TSHandleMLocRelease(bufp, hdr_loc, host_loc);
    TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc);
    goto done;
  }
  host_str = TSMimeHdrFieldValueStringGet(bufp,hdr_loc,host_loc,0,&host_length);	
  if (!host_str){                            
    TSError("couldn't retrieve request url string\n");
    TSHandleMLocRelease(bufp, hdr_loc, url_loc);
    TSHandleMLocRelease(bufp, hdr_loc, host_loc);
    TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc); 
    goto done;
  }
  host = strtok(const_cast<char*> (host_str), " \n\r");
  url_str = TSUrlStringGet(bufp, url_loc, &url_length);

  url = (char *) TSmalloc(strlen(url_str)+strlen(host));
  strncpy(url, url_str, x);
  url[x] = '\0';
  strcat(url, host);
  strcat(url, url_str+x);

  //TSDebug("banjax", "url_str = %s", url_str);
  //TSDebug("banjax", "host_str = %s", host_str);
  TSDebug("banjax", "%s", url);

  switch(response_type){
    case 1:
      buf = (char *) TSmalloc(4096);
      sprintf(buf, "You are forbidden from accessing this url: \"%s\"\n", url_str);
      break;
    case 2:
      //Retrieving the ip address
      client_address = (struct sockaddr_in*) TSHttpTxnClientAddrGet(txnp);
   
      if (!client_address) {
        TSError("error in retrieving client ip\n");
        TSHandleMLocRelease(bufp, hdr_loc, url_loc);
        TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc);                       
        goto done;
      }

      client_ip = inet_ntoa(client_address->sin_addr);
      TSDebug("banjax", "client_ip: %s",client_ip );

      time_validity = time(NULL) + 60*60*24; // TODO: one day validity for now, should be changed
      buf_str = ChallengeManager::generate_html(client_ip, time_validity, url);
      buf = (char *) TSmalloc(buf_str.length()+1);
      strcpy(buf, buf_str.c_str());
      break;
  } 

  TSfree(url_str);
  TSfree(url);
  TSHandleMLocRelease(bufp, hdr_loc, url_loc);
  TSHandleMLocRelease(bufp, TS_NULL_MLOC, hdr_loc);

  TSHttpTxnErrorBodySet(txnp, buf, strlen(buf), NULL);

done:
  TSHttpTxnReenable(txnp, TS_EVENT_HTTP_CONTINUE);

}

/**
   @param global_contp contains the global continuation and is sent here
   , so the new continuation gets the main banjax object
 */
void
ATSEventHandler::handle_txn_start(TSCont global_contp, TSHttpTxn txnp)
{
  TSCont txn_contp;
  BanjaxContinuation* global_cont_data = (BanjaxContinuation *) TSContDataGet(global_contp);;
  BanjaxContinuation *cd;

  //retreive the banjax obej

  txn_contp = TSContCreate((TSEventFunc) banjax_global_eventhandler, TSMutexCreate());
  /* create the data that'll be associated with the continuation */
  cd = (BanjaxContinuation *) TSmalloc(sizeof(BanjaxContinuation));
  cd = new(cd) BanjaxContinuation();
  TSContDataSet(txn_contp, cd);

  cd->txnp = txnp;
  cd->contp = txn_contp;
<<<<<<< HEAD
  cd->cur_banjax_inst = global_cont_data->cur_banjax_inst;
=======
  cd->response_type = 2;
>>>>>>> Redirct-traffic-to-solver

  TSHttpTxnHookAdd(txnp, TS_HTTP_READ_REQUEST_HDR_HOOK, txn_contp);
  TSHttpTxnHookAdd(txnp, TS_HTTP_TXN_CLOSE_HOOK, txn_contp);

  TSHttpTxnReenable(txnp, TS_EVENT_HTTP_CONTINUE);
}

void
ATSEventHandler::destroy_continuation(TSHttpTxn txnp, TSCont contp)
{
 
  BanjaxContinuation *cd = NULL;

  cd = (BanjaxContinuation *) TSContDataGet(contp);
  TSContDestroy(contp);
  TSHttpTxnReenable(cd->txnp, TS_EVENT_HTTP_CONTINUE);

  if (cd != NULL) {
    TSfree(cd);
    // delete cd;
  }
}


